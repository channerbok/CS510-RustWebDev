    WSL 2

    // Create file
    cargo new --bin webhello
    creates cargo.toml
    creates src file w/ main.rs
    
    // github repo with class code
    github-pdx-cs-rust-web/webhello.git

    // checks code
    RUN WITH CLIPPY
    RUN WITH CLIPPY
    RUN WITH CLIPPY
    RUN WITH CLIPPY
    change rust analyzer to use cargo CLIPPY

    // checks rust format
    cargo fmt will format the code

    // usize is big enough to index every portion of the var
    fn print_msg(msg: &str) -> usize{
        // Compiles then crashes
        todo!()

        println!("{}", msg);

        // no return statement needed
        msg.len();

    }


    fn main() {
        //Integrer types
        u8 u16 u32 u64 u128
        i8 i16 i32 i64 i128

        // Float types
        f32 f64

        // Boolean
        bool true false

        // Tuple, similar to structs, index with .?
       let x =  (1,"hello");
       x.0 x.1

       // Just one value, add the comma for tuple
       let y = (1,);

       // Unit, only can store the unit value. Unit value is returned from main.
       let z = ();

       let len = print_msg("hello world");
       println!("{}", len);

       // Can change value, is mutable
       let mut x = 5;
       x += 1;

       // let a = if a == 0 {
       let a = 5;
       let b = if a > 0 {
            "hello"
       } else {
            "goodbye"
       };


       // counts 10 to 1, the rev() reverses it
       // for i in (1u8 ..= 10).rev() {
        
       for i in (1 ..= 10u8).rev() {
        println!("{}",i);
       }
       println!("HELLO WORLD!");
        
    }


    struct Point{
        x: i64,
        y: i64,
    }


***Webserver Demo***

Minimal internet Knowledge

Network Layering:


Physical layer - packets on wire get sent; header or payload in the packet
provides information about the data. Has address in header, unique address. MAC address
(eth mac 0a:1b:2c:3d:4e:5f)

Internet Protocal layer - IPv4 - packets, headers, payload. Same of physical layer.
Wraps the physical payload. 4 bytes long
(IPv4 addr 1.217.3.4) "best effort, tries to deliver it to the destination"

TCP - Streams, ports, split and wrapped in IPv4. Wraps IP and handles
the packet sizes, order and makes it more reliable. Can send/recieve packets
through TCP stream. (16-bit port 3000)

HTTP - This is the language the web server speaks. Text based packets with
headers and body, wrapped by  TCP. Body is HTML. 
URL is who youre trying to communicate with.
(textual URL http://1.217.3.4/)

HTML - Special text in HTTP body.

TLS - encryption fr TCP streams, protects  HTTP
(used for "https")

DNS - Map names to IPv4 addresses
(example.org -> 1.217.3.4) 

We're gonna use Telnet as a web client/browser
telnet 142.250.217.78 80 connects to webserver of google.comm
HTTP/1.1 GET / will request data from the server


Writing our own web server:
!!!READ generic types and traits!!!

Man page: std::net - works w/ the internet

// Listens for incoming tcp connections
// Bind: TcpListener bound to address
// IPv4 addr is the correct type for to socket addr
// pub struct TcpListener()


use std::net::{IPv4Addr, SocketAddrV4, TcpListener};
use std::io::Write;

// Constant values
pub enum Option<T> {
    None,
    Some(T),
}

pub use Option::*;

// Array
// Max returns an max value in the array
// unwrap catches the error if array is empty
let m: u8 = [3, 3, 1].iter().max().unwrap();


pub enum Result<T, E> {
    Ok(T),
    Err(E),

} 

pub use Result::*;

fn main(){

    // Returns ip address for localhost
    let localhost = Ipv4Addr::new(127,0,0,1);

    // Socket address
    let socket_addr = SocketAddrV4::new(localhost,3000);

    // Listens for incoming tcp connections
    let tcp_listener = TcpListener::bind(socket_addr).unwrap();

    // accept connection method
    // Returns a tcp stream and socket addr
    // the _ is a pattern variable, it gets thrown out
    // This loops forever
    loop {
        let (mut tcp_stream, addr) tcp_listener.accept().unwrap();
        eprintln!("connection from{}", addr);
        // connect with telnet localhost 3000 in CMD
        // Will close immediately
        // _tcp_stream gets drop operation because its never used. its freed and the stream closes.

        // write to _tcp_stream
        write!(tcp_stream, "HTTP/1.0 200 Ok\r\n\r\n)
        write!(tcp_stream, "<html><body><em>hello world</em></body></html>").unwrap();

        // http://localhost:3000/ is connectable as a webserver

    }

    unwrap{
        flush();
    }
}